Tested on Ubuntu 14.04.2 LTS July 22 2015. 

Date: Thu, 21 May 2015 17:30:41 +0000 (GMT)
From: Philip Pettersson <p.pettersson@...sung.com>
To: oss-security@...ts.openwall.com
Subject: CVE-2015-1325 apport race conditions / ubuntu local root

Hello, this is CVE-2015-1325 which was reported to the Ubuntu Security Team
on 2015-05-11. 

There are several race conditions in the apport crash reporter, leading to a
reliable local root privilege escalation that affects all current LTS versions
of Ubuntu Server/Desktop (default install).

Apport is also available on other distributions but as far as I know it is
only in use by default on Ubuntu.

--- DETAILS

Apport is specified as the coredump handler (/proc/sys/kernel/core_pattern)
since at least Ubuntu 12.04.

When a process receives a signal that should generate a coredump,
/usr/share/apport/apport will be invoked by the kernel as root.

On line 284, apport "partially drops privileges":
	drop_privileges(pid, True)

However, this has no real security benefit since the euid of the process will
still be root. In fact, this will make the second part of the attached exploit
more reliable because it allows us to send the privileged apport process
SIGSTOP/SIGCONT and hit the last race easily.

On line 394 apport opens a file in /var/crash:
	with open(report, 'rb') as f:

report is the filename, which can be easily predicted. If a user with uid 1000
makes /bin/sleep crash, the filename will be: /var/crash/_bin_sleep.1000.crash

The directory /var/crash is world writable, so we can create a FIFO in this
directory before making our program crash. Apport will then try to read our
file and hang on line 394 until a report is written to the FIFO by us.

When apport is in this paused state, we can kill our original process and keep
forking until we get the same pid again. We then make this process execute
/bin/su which makes our original pid belong to a root process.

The drop_privileges() function on line 49 incorrectly uses the pid as the
indicator as to which uid we should drop privileges to:

def drop_privileges(pid, partial=False):
[...]
        stat = os.stat('/proc/%s/stat' % pid)
[...]
        effective_uid = stat.st_uid
[...]
        os.setreuid(stat.st_uid, effective_uid)

We can therefore make apport "drop" privileges to uid 0 and write a corefile
anywhere on the system.

This can be used to write a corefile with crafted contents in a suitable
location to gain root privileges.

On versions since at least Ubuntu 14.04 it is possible to completely control
the contents of the written corefile. This allows easy and reliable
exploitation by leveraging /etc/sudoers.d.

--- EXPLOIT FLOW

1. Create a FIFO in /var/crash/_bin_sleep.$uid.crash.
2. fork(), chdir("/etc/sudoers.d"), execute /bin/sleep and send SIGSEGV
3. Send SIGKILL to the process in (2), fork() until we get the same pid
   as the process we killed.
4. In our new process with the original pid, execute /bin/su.
5. Send valid report data to /var/crash/_bin_sleep.$uid.crash.
6. Core file is written to /etc/sudoers.d/core as root with mode 0600.

We could put this corefile in /etc/cron.hourly, /etc/logrotate.d and so on.

Additionally, on 14.04+ we can do this:

The partial privilege drop on line 284 allows us to send SIGSTOP to apport,
which gives us great control over the execution flow. On line 460 apport will
ultimately write the corefile contents by reading from the report file it just
created in /var/crash.

7. Keep sending SIGSTOP/SIGCONT until these lines have been executed:
   404: os.unlink(report)
   410: reportfile = os.fdopen(os.open(report, os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0), 'wb')
8. Unlink /var/crash/_bin_sleep.$uid.crash
9. Create FIFO in /var/crash/_bin_sleep.$uid.crash
10. Write crafted contents to /var/crash/_bin_sleep.$uid.crash
11. Apport will read our FIFO at line 155 and create a corefile with our
    crafted contents.

--- CREDIT

Philip Pettersson, Samsung SDS Security Center
