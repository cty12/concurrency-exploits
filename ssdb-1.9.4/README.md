## SSDB Null-Pointer-Dereference Vulnerability
SSDB-1.9.4(latest) has an null-pointer-dereference vulnerabililty triggered by a concurrency bug. One thread frees the memory(destructor) and the other thread still uses the memory(function pointer dereference). This bug could potentially cause ssdb lose all/partial critical transaction logs and server crush during shutdown. This readme will go through this vulnerability starts from the original thread sanitizer report to acutal code analysis and finally, our screenshot in reproducing the vulnerabililty in GDB.

Original Thread Sanitizer Reports
```
WARNING: ThreadSanitizer: data race (pid=6502)                                     
  Write of size 8 at 0x7d200000be00 by main thread:                                
    #0 BinlogQueue::~BinlogQueue() /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb/binlog.cpp:211:2 (ssdb-server+0x00000052f478)
    #1 SSDBImpl::~SSDBImpl() /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb/ssdb_impl.cpp:25:3 (ssdb-server+0x000000506ccc)
    #2 SSDBImpl::~SSDBImpl() /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb/ssdb_impl.cpp:23:22 (ssdb-server+0x000000506f78)
    #3 MyApplication::run() /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb-server.cpp:92:2 (ssdb-server+0x000000495056)
    #4 Application::main(int, char**) /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/util/app.cpp:17:2 (ssdb-server+0x00000054c518)
    #5 main /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb-server.cpp:99:9 (ssdb-server+0x0000004952fa)
                                                                                   
  Previous read of size 8 at 0x7d200000be00 by thread T1:                          
    #0 BinlogQueue::log_clean_thread_func(void*) /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb/binlog.cpp:370:7 (ssdb-server+0x00000052ee1d)
                                                                                   
  As if synchronized via sleep:                                                    
    #0 usleep /home/ruigu/Workspace/llvm-3.6.1.src/projects/compiler-rt/lib/tsan/rtl/tsan_interceptors.cc:281 (ssdb-server+0x000000435072)
    #1 BinlogQueue::~BinlogQueue() /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb/binlog.cpp:208:4 (ssdb-server+0x00000052f3fc)
    #2 SSDBImpl::~SSDBImpl() /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb/ssdb_impl.cpp:25:3 (ssdb-server+0x000000506ccc)
    #3 SSDBImpl::~SSDBImpl() /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb/ssdb_impl.cpp:23:22 (ssdb-server+0x000000506f78)
    #4 MyApplication::run() /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb-server.cpp:92:2 (ssdb-server+0x000000495056)
    #5 Application::main(int, char**) /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/util/app.cpp:17:2 (ssdb-server+0x00000054c518)
    #6 main /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb-server.cpp:99:9 (ssdb-server+0x0000004952fa)
                                                                                   
  Location is heap block of size 120 at 0x7d200000be00 allocated by main thread:
    #0 operator new(unsigned long) /home/ruigu/Workspace/llvm-3.6.1.src/projects/compiler-rt/lib/tsan/rtl/tsan_interceptors.cc:571 (ssdb-server+0x00000043c3d8)
    #1 SSDB::open(Options const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb/ssdb_impl.cpp:60:18 (ssdb-server+0x000000507687)
    #2 MyApplication::run() /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb-server.cpp:66:12 (ssdb-server+0x000000494936)
    #3 Application::main(int, char**) /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/util/app.cpp:17:2 (ssdb-server+0x00000054c518)
    #4 main /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb-server.cpp:99:9 (ssdb-server+0x0000004952fa)
                                                                                   
  Thread T1 (tid=6516, finished) created by main thread at:                        
    #0 pthread_create /home/ruigu/Workspace/llvm-3.6.1.src/projects/compiler-rt/lib/tsan/rtl/tsan_interceptors.cc:896 (ssdb-server+0x0000004235a6)
    #1 BinlogQueue::BinlogQueue(leveldb::DB*, bool, int) /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb/binlog.cpp:193:13 (ssdb-server+0x00000052e228)
    #2 SSDB::open(Options const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb/ssdb_impl.cpp:60:18 (ssdb-server+0x00000050775a)
    #3 MyApplication::run() /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb-server.cpp:66:12 (ssdb-server+0x000000494936)
    #4 Application::main(int, char**) /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/util/app.cpp:17:2 (ssdb-server+0x00000054c518)
    #5 main /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb-server.cpp:99:9 (ssdb-server+0x0000004952fa)
                                                                                   
SUMMARY: ThreadSanitizer: data race /home/ruigu/Workspace/concurrency-exploits/ssdb-1.9.4/ssdb-master/src/ssdb/binlog.cpp:211 BinlogQueue::~BinlogQueue()

```
Analysis
ssdb-master/src/ssdb/binlog.cpp
```C
352 int BinlogQueue::del_range(uint64_t start, uint64_t end){                       
353   while(start <= end){                                                          
354     leveldb::WriteBatch batch;                                                  
355     for(int count = 0; start <= end && count < 1000; start++, count++){         
356       batch.Delete(encode_seq_key(start));                                      
357     }                                                                           
358     leveldb::Status s = db->Write(leveldb::WriteOptions(), &batch);             
359     if(!s.ok()){                                                                
360       return -1;                                                                
361     }                                                                           
362   }                                                                             
363   return 0;                                                                     
364 }                                                                               
365                                                                                 
366 void* BinlogQueue::log_clean_thread_func(void *arg){                            
367   BinlogQueue *logs = (BinlogQueue *)arg;                                       
368                                                                                 
369   while(!logs->thread_quit){                                                    
370     if(!logs->db){                                                              
371       break;                                                                    
372     }                                                                           
373     assert(logs->last_seq >= logs->min_seq_);                                   
374                                                                                 
375     if(logs->last_seq - logs->min_seq_ < logs->capacity + 10000){               
376       usleep(50 * 1000);                                                        
377       continue;                                                                 
378     }                                                                           
379                                                                                 
380     uint64_t start = logs->min_seq_;                                            
381     uint64_t end = logs->last_seq - logs->capacity;                             
382     logs->del_range(start, end);                                                
383     logs->min_seq_ = end + 1;                                                   
384     log_info("clean %d logs[%" PRIu64 " ~ %" PRIu64 "], %d left, max: %" PRIu64 "",
385       end-start+1, start, end, logs->last_seq - logs->min_seq_ + 1, logs->last_seq);
386   }                                                                             
387   log_debug("binlog clean_thread quit");                                        
388                                                                                 
389   logs->thread_quit = false;                                                    
390   return (void *)NULL;                                                          
391 }                                                                               

```
ssdb-master/src/ssdb/binlog.cpp
```C
201 BinlogQueue::~BinlogQueue(){                                                    
202   if(this->enabled){                                                            
203     thread_quit = true;                                                         
204     for(int i=0; i<100; i++){                                                   
205       if(thread_quit == false){                                                 
206         break;                                                                  
207       }                                                                         
208       usleep(10 * 1000);                                                        
209     }                                                                           
210   }                                                                             
211   db = NULL;                                                                    
212 }                                                                               
```
Line 358 and Line 211 in the above code can be reached simultaneously. "db" is a class variable of class BinlogQueue. As a result, the function dereference operation on line 358 dereferences memory area that is already be set to null.

I've also uploaded the screenshot(ssdb-vulnerability-reproduce.png) in this page using GDB to reproduce this vulnerability. The GDB result indicates that those two locations can be indeed reached by different threads and accessing the same shared variable. After we successfully reproduce the bug, a server crush is also presented.
