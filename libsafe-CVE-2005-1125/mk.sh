# the following has been tested in Ubuntu 12.04 LTS 32-bit
# It will not work in 64-bit as libsafe is designed for 32-bit addresses

wget http://pkgs.fedoraproject.org/repo/pkgs/libsafe/libsafe-2.0-16.tgz/6b7b6e6df84d4afb469ccc66d04fc24d/libsafe-2.0-16.tgz
tar xvzf libsafe-2.0-16.tgz
cd libsafe-2.0-16
make
cd ..
gcc -g -O0 test.c -fno-stack-protector -fno-builtin -lpthread
export LD_PRELOAD=`pwd`/libsafe-2.0-16/src/libsafe.so:/usr/lib/i386-linux-gnu/libdl.so
# You could see different behavior in gdb
gdb ./a.out
# execute "r" several times
# sometimes, the program will be killed by libsafe
# sometimes, the program will run into buffer overflow vulnerability

# for toy*.c, use the same tricks above:
# 1. don't forget to export LD_PRELOAD
# 2. compile with -fno-stack-protector -fno-builtin -lpthread
# directly run those two toys without gdb.
# you can see the normal one is detected by libsafe, while the bypass one does not
# if it does not work, try the following:
# use gdb to start the program, check shellcode address by
# p &shellcode
# in my case, it is 0x804a040
# then use (since little-endian) \x40\xa0\x04\x08 for filling up the stacks in strcpy function
