#!/bin/bash

# The following has been tested in Ubuntu 14.04 LTS 32-bit
# libsafe is designed *only* for 32-bit addresses
sys_version=`uname -m`
if [ $sys_version == "x86_64" ]
then
    echo "Error: libsafe requires the system to be 32 bit machine!"
    exit 1
fi

# Download the source code
if [ -f 'libsafe-2.0-16.tgz' ]
then
    echo "Source code tar ball already downloaded. Skip the downloading process."
else
    wget http://pkgs.fedoraproject.org/repo/pkgs/libsafe/libsafe-2.0-16.tgz/6b7b6e6df84d4afb469ccc66d04fc24d/libsafe-2.0-16.tgz
fi

if [ -d 'libsafe-2.0-16' ]
then
    echo "Source code folder already existed. Skip the extraction process."
else
    tar xvzf libsafe-2.0-16.tgz
fi
cd libsafe-2.0-16/src

# Patch the source code to enable debugging info
patch < ../../debug_info.patch --dry-run
if [$? -nq 0 ]
then
    echo "Error: Applying patch failed. Please check the file path."
    exit 1
else
    patch < ../../debug_info.patch
fi

# Compile libsafe
cd ..
make clean && make
cd ..
gcc -g -O0 toy_bypass.c -o toy_bypass -fno-stack-protector -fno-builtin -lpthread

# If you want to check out the result, please run the following command.
#LD_PRELOAD=`pwd`/libsafe-2.0-16/src/libsafe.so:/usr/lib/i386-linux-gnu/libdl.so ./toy_bypass

# execute "r" several times
# sometimes, the program will be killed by libsafe
# sometimes, the program will run into buffer overflow vulnerability

# for toy*.c, use the same tricks above:
# 1. don't forget to export LD_PRELOAD
# 2. compile with -fno-stack-protector -fno-builtin -lpthread
# directly run those two toys without gdb.
# you can see the normal one is detected by libsafe, while the bypass one does not
# if it does not work, try the following:
# use gdb to start the program, check shellcode address by
# p &shellcode
# in my case, it is 0x804a040
# then use (since little-endian) \x40\xa0\x04\x08 for filling up the stacks in strcpy function
