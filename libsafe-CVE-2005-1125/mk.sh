#!/bin/bash

# the following has been tested in Ubuntu 14.04 LTS 32-bit
# libsafe is designed *only* for 32-bit addresses
sys_version=`uname -m`
if [ $sys_version == "x86_64" ]
then
    echo "Error: libsafe requires the system to be 32 bit machine!"
    exit
fi

wget http://pkgs.fedoraproject.org/repo/pkgs/libsafe/libsafe-2.0-16.tgz/6b7b6e6df84d4afb469ccc66d04fc24d/libsafe-2.0-16.tgz
tar xvzf libsafe-2.0-16.tgz
cd libsafe-2.0-16
make
cd ..
gcc -g -O0 toy_bypass.c -o toy_bypass -fno-stack-protector -fno-builtin -lpthread
LD_PRELOAD=`pwd`/libsafe-2.0-16/src/libsafe.so:/usr/lib/i386-linux-gnu/libdl.so ./toy_bypass

# execute "r" several times
# sometimes, the program will be killed by libsafe
# sometimes, the program will run into buffer overflow vulnerability

# for toy*.c, use the same tricks above:
# 1. don't forget to export LD_PRELOAD
# 2. compile with -fno-stack-protector -fno-builtin -lpthread
# directly run those two toys without gdb.
# you can see the normal one is detected by libsafe, while the bypass one does not
# if it does not work, try the following:
# use gdb to start the program, check shellcode address by
# p &shellcode
# in my case, it is 0x804a040
# then use (since little-endian) \x40\xa0\x04\x08 for filling up the stacks in strcpy function
