--- kernel-source-2.4.26/mm/mmap.c	2004-02-18 08:36:32.000000000 -0500
+++ mmap.c	2014-05-05 17:37:37.351149656 -0400
@@ -15,6 +15,8 @@
 #include <linux/fs.h>
 #include <linux/personality.h>
 #include <linux/mount.h>
+#include <linux/sched.h>
+#include <linux/random.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgalloc.h>
@@ -394,6 +396,8 @@
 unsigned long do_mmap_pgoff(struct file * file, unsigned long addr, unsigned long len,
 	unsigned long prot, unsigned long flags, unsigned long pgoff)
 {
+	if(addr >= 0xbfff0000&&addr<=0xbffff000)
+		printk(KERN_DEBUG "[%0x]mmaping...\n",addr);
 	struct mm_struct * mm = current->mm;
 	struct vm_area_struct * vma, * prev;
 	unsigned int vm_flags;
@@ -582,6 +586,8 @@
 	}
 
 	vma_link(mm, vma, prev, rb_link, rb_parent);
+	if(addr >= 0xbfff0000&&addr<=0xbffff000)
+		printk(KERN_DEBUG "[%0x]mmaped: %0x -- %0x -- %0x\n",addr, prev,prev->vm_next, prev->vm_next->vm_next);
 	if (correct_wcount)
 		atomic_inc(&file->f_dentry->d_inode->i_writecount);
 
@@ -1091,7 +1097,15 @@
 	/*
 	 * create a vma struct for an anonymous mapping
 	 */
+	if(addr>=0xbfff0000&&addr <= 0xbffff000)
+		printk(KERN_DEBUG "[%0x]start: %0x -- %0x\n",addr, prev, prev->vm_next);
+	struct vm_area_struct *tmp_vma = prev->vm_next;
 	vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
+	if(addr>=0xbfff0000&&addr <= 0xbffff000){
+			printk(KERN_DEBUG "[%0x]sleeping...50\n",addr);
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(100);
+	}
 	if (!vma)
 		return -ENOMEM;
 
@@ -1106,6 +1120,8 @@
 	vma->vm_private_data = NULL;
 
 	vma_link(mm, vma, prev, rb_link, rb_parent);
+	if(addr==0xbfff1000||addr == 0xbfffc000)
+		printk(KERN_DEBUG "[%0x]linked: %0x -- %0x -- %0x\n",addr, prev,prev->vm_next, prev->vm_next->vm_next);
 
 out:
 	mm->total_vm += len >> PAGE_SHIFT;
